# I18n System

Built-in internationalization for service messages with a 3-level fallback chain.

---

## Message Lookup Chain

### Fallback Order

How BetterService resolves message translations.

```ruby
# When you call message("create.success"), BetterService looks up in order:

# 1. Custom namespace: {namespace}.services.create.success
# 2. Default BetterService: better_service.services.default.create.success
# 3. Key itself: Returns "create.success" as fallback
```

--------------------------------

## Configuration

### Set Namespace in BaseService

Configure the I18n namespace for a resource.

```ruby
class Product::BaseService < BetterService::Services::Base
  messages_namespace :products  # Custom namespace for this resource
end
```

--------------------------------

### Locale File Structure

Standard locale file organization.

```yaml
# config/locales/product_services.en.yml
en:
  products:
    services:
      index:
        success: "Products retrieved successfully"
      show:
        success: "Product details loaded"
      create:
        success: "Product %{name} created successfully"
      update:
        success: "Product updated successfully"
      destroy:
        success: "Product deleted successfully"
      publish:
        success: "Product %{name} is now published"
        already_published: "Product is already published"
```

--------------------------------

### Default Messages

BetterService's built-in default messages.

```yaml
# config/locales/better_service.en.yml (installed with generator)
en:
  better_service:
    services:
      default:
        index:
          success: "Records retrieved successfully"
        show:
          success: "Record retrieved successfully"
        create:
          success: "Record created successfully"
        update:
          success: "Record updated successfully"
        destroy:
          success: "Record deleted successfully"
```

--------------------------------

## Basic Usage

### Using the Message Helper

Access translations in services.

```ruby
class Product::CreateService < Product::BaseService
  performed_action :created

  respond_with do |data|
    success_result(message("create.success"), data)
  end
end
```

--------------------------------

## With Interpolation

### Dynamic Message Content

Pass variables to message translations.

```ruby
respond_with do |data|
  success_result(
    message("create.success", name: data[:resource].name),
    data
  )
end

# Locale: "Product %{name} created successfully"
# Output: "Product Widget created successfully"
```

--------------------------------

### Multiple Interpolations

Pass multiple variables to messages.

```ruby
respond_with do |data|
  success_result(
    message("create.success",
      name: data[:resource].name,
      price: data[:resource].price,
      user: user.name
    ),
    data
  )
end

# Locale: "Product %{name} ($%{price}) created by %{user}"
# Output: "Product Widget ($99.99) created by John"
```

--------------------------------

## Generate Locale File

### Locale Generator

Generate a locale file for a resource.

```bash
rails g better_service:locale products
```

```ruby
# Generates config/locales/products_services.en.yml with standard CRUD messages
```

--------------------------------

## Complete Locale Example

### Full Locale File

Comprehensive locale file with all message types.

```yaml
# config/locales/product_services.en.yml
en:
  products:
    services:
      # CRUD operations
      index:
        success: "Found %{count} products"
        empty: "No products found"
      show:
        success: "Product loaded"
        not_found: "Product not found"
      create:
        success: "Product %{name} created successfully"
        failed: "Could not create product"
      update:
        success: "Product updated successfully"
        failed: "Could not update product"
        no_changes: "No changes were made"
      destroy:
        success: "Product deleted successfully"
        failed: "Could not delete product"
        has_orders: "Cannot delete product with existing orders"

      # Custom actions
      publish:
        success: "Product %{name} is now published"
        already_published: "Product is already published"
        not_ready: "Product is not ready for publishing"
      archive:
        success: "Product archived"
        already_archived: "Product is already archived"
      duplicate:
        success: "Product duplicated as %{name}"

      # Validation messages
      validation:
        name_required: "Product name is required"
        price_invalid: "Price must be greater than 0"
        category_required: "Please select a category"

      # Authorization messages
      authorization:
        not_owner: "You can only modify your own products"
        admin_required: "Admin access required"
```

--------------------------------

## Index with Count

### Dynamic Count Messages

Use different messages based on results.

```ruby
class Product::IndexService < Product::BaseService
  performed_action :listed

  respond_with do |data|
    items = data[:items]
    msg = items.any? ?
      message("index.success", count: items.size) :
      message("index.empty")

    success_result(msg, data)
  end
end
```

--------------------------------

## Custom Action Messages

### Messages for Custom Actions

Use messages in custom action services.

```ruby
class Product::PublishService < Product::BaseService
  performed_action :published

  process_with do |data|
    product = data[:resource]

    if product.published?
      raise BetterService::Errors::Runtime::ExecutionError.new(
        message("publish.already_published"),
        context: { id: product.id }
      )
    end

    product_repository.update!(product, published: true)
    { resource: product.reload }
  end

  respond_with do |data|
    success_result(
      message("publish.success", name: data[:resource].name),
      data
    )
  end
end
```

--------------------------------

## Conditional Messages

### Different Messages Based on State

Return different messages based on conditions.

```ruby
class Product::UpdateService < Product::BaseService
  performed_action :updated

  process_with do |data|
    product = data[:resource]
    update_params = params.except(:id).compact

    if update_params.empty?
      # No changes to make
      return { resource: product, no_changes: true }
    end

    product_repository.update!(product, update_params)
    { resource: product.reload }
  end

  respond_with do |data|
    msg = data[:no_changes] ?
      message("update.no_changes") :
      message("update.success")

    success_result(msg, data)
  end
end
```

--------------------------------

## Multiple Languages

### Multi-Language Support

Define translations for multiple locales.

```yaml
# config/locales/product_services.en.yml
en:
  products:
    services:
      create:
        success: "Product %{name} created successfully"

# config/locales/product_services.it.yml
it:
  products:
    services:
      create:
        success: "Prodotto %{name} creato con successo"

# config/locales/product_services.es.yml
es:
  products:
    services:
      create:
        success: "Producto %{name} creado exitosamente"
```

--------------------------------

## Best Practices

### I18n Recommendations

Guidelines for effective internationalization.

```ruby
# 1. Always use message helper - Don't hardcode strings
message("create.success")  # CORRECT
"Product created"          # WRONG

# 2. Use interpolation - Make messages dynamic
message("create.success", name: product.name)

# 3. Provide context - Include relevant data
message("error.limit_exceeded", limit: 100, current: 150)

# 4. Be consistent - Follow naming conventions
# action.outcome pattern: create.success, update.failed, publish.already_published

# 5. Generate locale files - Use generators for standard structure
rails g better_service:locale products
```

--------------------------------
